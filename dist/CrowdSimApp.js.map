{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/app/CrowdSimApp.js","src/app/Render/Agent.js","src/app/Render/Base.js","src/app/Render/Context.js","src/app/Render/Detail.js","src/app/Render/Entity.js","src/app/Render/Group.js","src/app/Render/Joint.js","src/app/Render/LinePrototype.js","src/app/Render/Path.js","src/app/Render/Render.js","src/app/Render/Wall.js","src/app/Worlds.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5dA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"CrowdSimApp.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","'use strict';\r\n\r\nvar CrowdSim = require('CrowdSim');\r\nvar Render = require('./Render/Render');\r\nvar Worlds = require('./Worlds');\r\n\r\nvar App = {};\r\n\r\nApp.defaultOptions = {\r\n  // callbacks\r\n  debug: true,\r\n  snapToGrid: false, // snaps the mouse position to a grid of integers\r\n  logEvents: false,\r\n  renderer: {\r\n    scale: 10,\r\n    MaxAgents: 1000, // to init particle container\r\n    debug: true,\r\n  },\r\n  callbacks: {\r\n    onPreRender: null, // before each render cycle\r\n    onPostRender: null, // after each render cycle\r\n    onCreateEntity: null, // on creation of complex entites\r\n    onDestroyEntity: null, // on removing of complex entites\r\n    onEntitySelected: null,\r\n    onEntityUnSelected: null,\r\n    onLoad: null, // when new world is loaded\r\n    onSave: null, // when the current world is saved\r\n  }\r\n};\r\n\r\n// wire entities <=> render entities association\r\nApp.EntityTypes = {\r\n  Group: Render.Group,\r\n  Context: Render.Context,\r\n  Path: Render.Path,\r\n  Wall: Render.Wall,\r\n};\r\n\r\n// wires creation of render entities from model entities\r\nApp.EntityCreationMapping = {\r\n  'context': Render.Context,\r\n  'group': Render.Group,\r\n  'path': Render.Path,\r\n  'wall': Render.Wall\r\n};\r\n\r\nApp.resize = function(window, width, height) {\r\n  // to wait for fullscreen state\r\n  setTimeout(function() {\r\n    var w = width || window.innerWidth;\r\n    var h = height || window.innerHeight;\r\n    App._renderer.resize(w, h);\r\n  }, 200);\r\n};\r\n\r\nApp.init = function(canvas, options) {\r\n  App.options = Lazy(options).defaults(App.defaultOptions).toObject();\r\n  App.callbacks = Lazy(options.callbacks).defaults(App.defaultOptions.callbacks).toObject();\r\n\r\n  delete App.options.callbacks;\r\n  App.canvas = canvas;\r\n\r\n  var w = options.width;\r\n  var h = options.height;\r\n\r\n  App._renderer = new Render(canvas, w, h, App.options.renderer);\r\n  var textures = {\r\n    file: 'img/flt.png',\r\n    agent: [26, 16, 51, 36],\r\n    wall: [274, 14, 32, 32],\r\n    path: [326, 14, 32, 32]\r\n  };\r\n  App._engine = new CrowdSim.Engine(App._world, {\r\n      timeStepSize: 0.1, // time per step\r\n      timeStepRun: 0.001 // time between step runnings\r\n    });\r\n  var events = {\r\n    mouseover: App.entity.mouseover,\r\n    mouseout: App.entity.mouseout,\r\n    mousedown: App.entity.mousedown,\r\n    mouseup: App.entity.mouseup,\r\n    mousemove: App.entity.mousemove\r\n  };\r\n  App._renderer.init(textures, events);\r\n  App._render();\r\n};\r\n\r\nApp.save = function() {\r\n  // TODO\r\n  App._world.save();\r\n  App.callbacks.onSave(App._world);\r\n};\r\n\r\nApp.loadExample = function(name) {\r\n  App.load(Worlds[name]);\r\n};\r\n\r\nApp.load = function(loader) {\r\n  var w = App._renderer.getWidth();\r\n  var h = App._renderer.getHeight();\r\n  var options = {\r\n    width: w,\r\n    height: h,\r\n    onCreateAgents: App.onCreateAgents,\r\n    onDestroyAgents: App.onDestroyAgents,\r\n    onCreateEntity: App.callbacks.onCreateEntity,\r\n    onDestroyEntity: App.callbacks.onDestroyEntity\r\n  };\r\n\r\n  var world = App._world = loader(App.options);\r\n  App._engine.setWorld(world);\r\n  // loads all entities creating render objects\r\n  Lazy(world.getEntities()).each(function(entity) {\r\n    App.addEntity(entity);\r\n  });\r\n\r\n  App.callbacks.onLoad(world);\r\n};\r\n\r\nApp.onCreateAgents = function(agents) {\r\n  Lazy(agents).each(function(a) {\r\n    new Render.Agent(a);\r\n  });\r\n};\r\n\r\nApp.onDestroyAgents = function(agents) {\r\n  Lazy(agents).each(function(a) {\r\n    a.view.destroy();\r\n  });\r\n};\r\n\r\nApp.createEntityStart = function(entityType, pos) {\r\n  var entity = entityType.CreateFromPoint(pos.x, pos.y, App._world);\r\n  App._newRenderEntity = entity;\r\n  if (App.callbacks.onCreateEntity) {\r\n    App.callbacks.onCreateEntity(App._newRenderEntity);\r\n  }\r\n  return App._newRenderEntity;\r\n};\r\n\r\n// returns current entity creation of null if finished\r\nApp.getCreatingEntity = function() {\r\n  return App._newRenderEntity;\r\n};\r\n\r\nApp.createEntityEnd = function() {\r\n  App._renderer.drawHelperLine(null);\r\n  App._newRenderEntity = null;\r\n  return null;\r\n};\r\n\r\nApp.destroyEntity = function(entity) {\r\n  entity.destroy();\r\n  if (App._entitySelected === entity) {\r\n    App.selectEntity(null);\r\n  }\r\n};\r\n\r\nApp.editEntity = function(entity) {\r\n  if (!App._newRenderEntity) { // stops from editing one entity if not finished with Previous\r\n    App._editingEntity = App._entitySelected;\r\n    if (App._editingEntity instanceof Render.Group) {\r\n      var group = App._editingEntity.getGroup();\r\n      // clear current associations\r\n      group.assignPath(null);\r\n      group.assignStartContext(null);\r\n      group.assignEndContext(null);\r\n    }\r\n  }\r\n};\r\n\r\nApp.addEntity = function(entity) {\r\n  var renderEntityProto = App.EntityCreationMapping[entity.constructor.type];\r\n  var renderEntity = renderEntityProto.CreateFromModel(entity, App._world);\r\n  if (App.callbacks.onCreateEntity) {\r\n    App.callbacks.onCreateEntity(renderEntity);\r\n  }\r\n};\r\n\r\nApp.getEngineSettings = function() {\r\n  return App._engine.getSettings();\r\n};\r\n\r\nApp.zoom = function(scale, x, y) {\r\n  App._renderer.zoom(scale, x, y);\r\n};\r\n\r\nApp.pan = function(dx, dy) {\r\n  App._renderer.pan(dx, dy);\r\n};\r\n\r\nApp.selectEntity = function(entity) {\r\n  if (App._entitySelected) {\r\n    // hack to hide in stage\r\n    App._entitySelected.hover = false;\r\n    if (App.callbacks.onEntityUnSelected) {\r\n      App.callbacks.onEntityUnSelected(App._entitySelected);\r\n    }\r\n  }\r\n  App._entitySelected = entity;\r\n  if (entity) {\r\n    // hack to show in stage\r\n    entity.hover = true;\r\n    if (App.callbacks.onEntitySelected) {\r\n      App.callbacks.onEntitySelected(App._entitySelected);\r\n    }\r\n  }\r\n};\r\n\r\nApp.getSelectedEntity = function() {\r\n  return App._entitySelected;\r\n};\r\n\r\nApp.selectEntityById = function(id) {\r\n  var entity = App._world.getEntityById(id);\r\n  App.selectEntity(entity.view);\r\n};\r\n\r\n/* Stagen a render entities mouse events */\r\nApp.entity = {};\r\n\r\nApp.entity.mousedown = function(event) {\r\n  if (App.options.logEvents) {\r\n    console.log(event);\r\n  }\r\n  // this points to the render entity\r\n  App._globalMousePressed = true;\r\n  this.entity.drag = true;\r\n  var point = event.data.getLocalPosition(this.parent);\r\n  if (this.entity.mousedown) {\r\n    this.entity.mousedown(point);\r\n  }\r\n  var anchor = this.entity.getAnchor();\r\n  this.mousedownAnchor = {x: anchor.x - point.x, y: anchor.y - point.y};\r\n  event.stopPropagation();\r\n  App.selectEntity(this.entity);\r\n  return false;\r\n};\r\n\r\nApp.entityClick = function(pos, newEntity, selected) {\r\n  if (newEntity instanceof Render.Joint) { // add joint to joint\r\n    var existingJoint = newEntity.getJoint();\r\n    existingJoint.parent.view.addJoint(pos.x, pos.y, {previousJoint: existingJoint});\r\n  } else if (newEntity instanceof Render.Wall) { // add joint to wall\r\n    newEntity.addJoint(pos.x, pos.y);\r\n  } else if (newEntity instanceof Render.Path) { // add join to waypoint\r\n    newEntity.addJoint(pos.x, pos.y); // use default radius\r\n  } else if (newEntity instanceof Render.Context) { // add context\r\n    newEntity.setArea(pos.x, pos.y);\r\n  } else if (newEntity instanceof Render.Group) { // add group\r\n    var group = newEntity.getGroup();\r\n    // for groups creation proccess is more complex a path, startcontext and endcontext could be assigned\r\n    if (selected instanceof Render.Joint) {\r\n      var joint = selected.getJoint();\r\n      var newPath = joint.parent;\r\n      var currentPath = group.getPath();\r\n      if (!currentPath) {\r\n        var idxInPath = newPath.getJointIdx(joint);\r\n        group.assignPath(newPath, idxInPath);\r\n      }\r\n    } else if (selected instanceof Render.Context) {\r\n      var context = selected.getContext();\r\n      var startContext = group.getStartContext();\r\n      var endContext = group.getEndContext();\r\n      if (!startContext) {\r\n        group.assignStartContext(context);\r\n      } else if (!endContext) {\r\n        group.assignEndContext(context);\r\n      }\r\n    } else {\r\n\r\n    }\r\n    // check if group is completed to end creation mode\r\n    if (group.getPath() && group.getStartContext() && group.getEndContext()) {\r\n      App.createEntityEnd();\r\n    }\r\n  }\r\n};\r\n\r\n// stage mousedown creation of entities steps\r\nApp.mousedown = function(event) {\r\n  if (App.options.logEvents) {\r\n    console.log(event);\r\n  }\r\n  App._globalMousePressed = true;\r\n  switch (event.button) {\r\n  case 0: // left button\r\n    if (App._editingEntity) { // change editing to create\r\n      App._newRenderEntity = App._editingEntity;\r\n      App._editingEntity = null;\r\n    } else if (App._newRenderEntity) { // creating/entities entities\r\n      var pos = App._renderer.screenToWorld(event.clientX, event.clientY);\r\n      App.entityClick(pos, App._newRenderEntity, App._entitySelected);\r\n    }\r\n  }\r\n};\r\n\r\nApp.entity.mousemove = function(event) {\r\n  // this points to the render entity\r\n  if (this.entity) {\r\n    if (!App._globalMousePressed) { // correct mouse up out of the entity\r\n      this.entity.drag = false;\r\n    }\r\n    if (this.entity.drag) {\r\n      var newPosition = event.data.getLocalPosition(this.parent);\r\n      if (App.snapToGrid) {\r\n        newPosition.x = Math.round(newPosition.x);\r\n        newPosition.y = Math.round(newPosition.y);\r\n      }\r\n      this.entity.dragTo(newPosition, this.mousedownAnchor);\r\n    }\r\n  }\r\n};\r\n\r\n// stage mousemove\r\nApp.mousemove = function(event) {\r\n  // this points to the graphics/sprite\r\n  if (App._newRenderEntity) {\r\n    var origin = App._newRenderEntity.getPos();\r\n    //var pos = event.data.getLocalPosition(this.parent);\r\n    var pos = App._renderer.screenToWorld(event.clientX, event.clientY);\r\n    App._renderer.drawHelperLine(origin[0], origin[1], pos.x, pos.y);\r\n  }\r\n};\r\n\r\nApp.mousewheel = function(event) {\r\n  var entity = App._entitySelected;\r\n  if (entity) {\r\n    if (entity instanceof Render.Joint) {\r\n      var joint  = entity.getJoint();\r\n      joint.incrRadius(event.deltaY);\r\n      return true;\r\n    } else if (entity instanceof Render.Context) {\r\n      var context  = entity.getContext();\r\n      context.incrSize(event.deltaY);\r\n      return true;\r\n    }\r\n  }\r\n};\r\n\r\nApp.entity.mouseup = function(event) {\r\n  if (App.options.logEvents) {\r\n    console.log(event);\r\n  }\r\n  // this points to the graphics/sprite\r\n  // to use in entities to end dragging action\r\n  App._globalMousePressed = false;\r\n  this.entity.drag = false;\r\n  if (this.entity.mouseup) {\r\n    this.entity.mouseup();\r\n  }\r\n  this.entity.mousedownAnchor = null;\r\n  event.stopPropagation();\r\n  return false;\r\n};\r\n\r\nApp.mouseup = function(event) {\r\n  if (App.options.logEvents) {\r\n    console.log(event);\r\n  }\r\n  // entities don't receive mouseup event when mouse is out\r\n  App._globalMousePressed = false;\r\n};\r\n\r\nApp.entity.mouseout = function(event) {\r\n  if (App.options.logEvents) {\r\n    console.log(event);\r\n  }\r\n  // this points to the graphics/sprite\r\n  this.entity.hover = false;\r\n  this.entity.tint = 0x999999;\r\n};\r\n\r\nApp.entity.mouseover = function(event) {\r\n  if (App.options.logEvents) {\r\n    console.log(event);\r\n  }\r\n  // this points to the graphics/sprite\r\n  this.entity.hover = true;\r\n  this.entity.tint = 0xFFFFFF;\r\n};\r\n\r\nApp.screenToWorld = function(x, y) {\r\n  return App._renderer.screenToWorld(x, y);\r\n};\r\nApp.worldToScreen = function(x, y) {\r\n  return App._renderer.worldToScreen(x, y);\r\n};\r\n\r\nApp.toggleRun = function() {\r\n  if (App.isRunning()) {\r\n    return App.stop();\r\n  } else {\r\n    return App.run();\r\n  }\r\n};\r\n\r\nApp.isRunning = function() {\r\n  return App._engine.running;\r\n};\r\n\r\nApp.run = function() {\r\n  var isRunning = App._engine.run();\r\n  return isRunning;\r\n};\r\n\r\nApp.stop = function() {\r\n  var isRunning = App._engine.stop();\r\n  return isRunning;\r\n};\r\n\r\nApp.step = function() {\r\n  App._engine.step();\r\n};\r\n\r\nApp.reset = function() {\r\n  App._engine.reset();\r\n};\r\n\r\nApp.getStats = function() {\r\n  var entities = App._world.entities;\r\n  return {\r\n    running: App._engine.running,\r\n    iterations: App._engine.iterations,\r\n    groups: App._world.getGroups().length,\r\n    agents: App._world.getAgents().length,\r\n    contexts: entities.contexts.length,\r\n    walls: entities.walls.length,\r\n    paths: entities.paths.length,\r\n    agent: App._world.agentSelected ? App._world.agentSelected.id : ''\r\n  };\r\n};\r\n\r\nApp.cycleDetail = function(entityType) {\r\n  entityType.detail.cycleDetail();\r\n};\r\n\r\nApp._render = function() {\r\n  // callback prerender\r\n  if (App.callbacks.onPreRender) {\r\n    App.callbacks.onPreRender();\r\n  }\r\n\r\n  if (App._world) {\r\n    var entities = App._world.entities;\r\n\r\n    // render/refresh entities\r\n    var agents = App._world.getAgents();\r\n    for (var i in agents) {\r\n      agents[i].view.render();\r\n    }\r\n\r\n    for (var prop in entities) {\r\n      Lazy(entities[prop]).each(function(a) {\r\n        if (a.view) { a.view.render(); }\r\n      });\r\n    }\r\n  }\r\n\r\n  // render the stage\r\n  App._renderer.render();\r\n\r\n  // callback postrender\r\n  if (App.callbacks.onPostRender) {\r\n    App.callbacks.onPostRender();\r\n  }\r\n\r\n  requestAnimationFrame(App._render);\r\n};\r\n\r\nmodule.exports = App;\r\n\r\n// browser\r\nif (typeof window === 'object' && typeof window.document === 'object') {\r\n  window.CrowdSimApp = App;\r\n}\r\n","'use strict';\n\nvar Vec2 = require('CrowdSim').Vec2;\nvar Base = require('./Base');\nvar Entity = require('./Entity');\nvar Detail = require('./Detail');\nvar Colors = Base.Colors;\n\nvar Agent = function(agent) {\n  if (!agent) {\n    throw 'Agent object must be defined';\n  }\n  //var display = new PIXI.Sprite(options.texture);\n\n  Entity.call(this, agent);\n  this.sprite = new PIXI.Sprite(Agent.texture);\n  Entity.prototype.createGraphics.call(this,Agent.container, this.sprite);\n  this.sprite.visible = Agent.detail.level > 0;\n  this.sprite.anchor.set(0.5);\n  //this.display.alpha = 0.5;\n  var size = agent.size;\n  this.sprite.height = size;\n  this.sprite.width = size;\n  this.sprite.position.x = agent.pos[0];\n  this.sprite.position.y = agent.pos[1];\n};\n\nAgent.prototype.destroy = function() {\n  Entity.prototype.destroyGraphics.call(this,Agent.container, this.sprite);\n  Entity.prototype.destroyGraphics.call(this,Agent.container, this.graphics);\n};\n\nAgent.prototype.render = function() {\n  if (!Agent.detail.level) {\n    this.sprite.visible = false;\n    this.sprite.alpha = 0;\n    if (this.graphics) {\n      this.graphics.clear();\n    }\n    return;\n  } else {\n    this.sprite.alpha = 1;\n    this.sprite.visible = true;\n  }\n  Entity.prototype.render.call(this);\n\n  var e = this.entityModel;\n  this.sprite.position.set(e.pos[0], e.pos[1]);\n  this.sprite.rotation = Math.atan2(e.vel[1], e.vel[0]) - Math.PI / 2;\n\n  if (Agent.detail.level > 1) {\n    if (!this.graphics) {\n      this.graphics = Entity.prototype.createGraphics.call(this,Agent.debugContainer);\n      this.circle = new PIXI.Circle(e.pos[0],e.pos[1], e.size / 2);\n      //this.graphics.addChild(this.circle);\n    }\n    this.graphics.clear();\n  }\n\n  if (Agent.detail.level > 1) {\n    if (this.circle) {\n      this.circle.x = e.pos[0];\n      this.circle.y = e.pos[1];\n      this.graphics.lineStyle(0.1, Colors.Agent);\n      this.graphics.drawShape(this.circle);\n    }\n  }\n  if (Agent.detail.level > 2) {\n    this.graphics.moveTo(e.pos[0], e.pos[1]);\n    this.graphics.lineTo(e.pos[0] + e.vel[0], e.pos[1] + e.vel[1]);\n  }\n  if (e.debug) {\n    if (Agent.detail.level > 3 && e.debug.forces) {\n      var force = Vec2.create();\n      for (var f in e.debug.forces) {\n        this.graphics.lineStyle(0.1, Colors.Forces[f]);\n        this.graphics.moveTo(e.pos[0], e.pos[1]);\n        Vec2.normalize(force, e.debug.forces[f]);\n        this.graphics.lineTo(e.pos[0] + force[0], e.pos[1] + force[1]);\n      }\n    }\n    if (isNaN(e.pos[0]) || isNaN(e.pos[1])) {\n      throw 'Agent position undefined';\n    }\n  }\n};\n\nAgent.texture = null; // agents texture\nAgent.debugContainer = null; // special container use to render all agents, e.g particleContainer\nAgent.detail = new Detail(4);\n\nmodule.exports = Agent;\n","'use strict';\r\n\r\nvar Colors = {\r\n  Hover: 0xebff00,\r\n  Context: 0x646729,\r\n  Agent: 0xFF0000,\r\n  Group: 0xFFFFFF,\r\n  Wall: 0x00FF00,\r\n  Joint: 0xAAAAAA,\r\n  Path: 0xe00777,\r\n  Waypoint: 0x7a7a7a,\r\n  Forces: {desired: 0xfffff,\r\n          agents: 0xFF0000,\r\n          walls: 0xc49220\r\n        },\r\n  Helpers: 0xFFFFFF\r\n};\r\n\r\nvar Fonts = {\r\n  default: {font: '2px Mono monospace', fill: 0xFFFFFF,\r\n  align: 'center'},\r\n  resolution: 12\r\n};\r\n\r\nmodule.exports.Colors = Colors;\r\nmodule.exports.Fonts = Fonts;\r\n","'use strict';\n\nvar ContextModel = require('CrowdSim').Context;\nvar Base = require('./Base');\nvar Entity = require('./Entity');\nvar Detail = require('./Detail');\nvar Colors = Base.Colors;\n\nvar Context = function(context) {\n  if (!context) {\n    throw 'Context object must be defined';\n  }\n  Entity.call(this, context);\n};\n\nContext.CreateFromModel = function(context) {\n  return new Context(context);\n};\n\nContext.CreateFromPoint = function(x, y, parent, options) {\n  var context = new ContextModel(x, y, parent, options);\n  return new Context(context);\n};\n\nContext.prototype.destroy = function() {\n  Entity.prototype.destroyGraphics.call(this,Context.container, this.graphics);\n  Entity.prototype.destroy.call(this);\n};\n\nContext.prototype.createGraphics = function(context) {\n  this.graphics = Entity.prototype.createGraphics.call(this,Context.container);\n  this.label = new PIXI.Text(context.id, Base.Fonts.default);\n  this.label.resolution = Base.Fonts.resolution;\n  this.graphics.addChild(this.label);\n  this.rect = new PIXI.Rectangle(0, 0, 0, 0);\n  this.rect.entityModel = context;\n  this.graphics.entity = this;\n};\n\nContext.prototype.getAnchor = function(init) {\n  var context = this.entityModel;\n  return {x: context.pos[0], y: context.pos[1]};\n};\n\nContext.prototype.dragTo = function(pos, anchor) {\n  var context = this.entityModel;\n  context.pos[0] = pos.x;\n  context.pos[1] = pos.y;\n};\n\nContext.prototype.render = function(options) {\n  if (!Context.detail.level) {\n    this.graphics.clear();\n    return;\n  }\n  Entity.prototype.render.call(this,this.graphics);\n  var context = this.entityModel;\n  // init render\n  if (!this.graphics && Context.detail.level) {\n    this.createGraphics(context);\n  } else {\n    this.graphics.clear();\n  }\n\n  if (Context.detail.level > 0) {\n    var w = context.getWidth();\n    var h = context.getHeight();\n    this.rect.x = context.pos[0] - w / 2;\n    this.rect.y = context.pos[1] - h / 2;\n    this.rect.width = w;\n    this.rect.height = h;\n    this.label.x = context.pos[0] - this.label.width / 2;\n    this.label.y = context.pos[1] - this.label.height / 2;\n    this.graphics.beginFill(this.hover ? Colors.Hover : Colors.Context, this.hover ? 0.9 : 0.3);\n    this.graphics.drawShape(this.rect);\n    this.graphics.endFill();\n  }\n};\n\nContext.prototype.setArea = function(x, y) {\n  this.entityModel.setArea(x, y);\n};\n\nContext.prototype.getContext = function() {\n  return this.entityModel;\n};\n\nContext.prototype.getPos = function() {\n  return Entity.prototype.getPos.call(this);\n};\n\nContext.detail = new Detail(2);\n\nmodule.exports = Context;\n","'use strict';\r\n\r\nvar Detail = function(maxDetail, detail) {\r\n  this.maxDetail = maxDetail;\r\n  this.level = detail || 1;\r\n};\r\n\r\nDetail.prototype.cycleDetail = function(detail) {\r\n  if (detail) {\r\n    this.level = detail;\r\n  } else {\r\n    this.level ++;\r\n    if (this.level > this.maxDetail) {\r\n      this.level = 0;\r\n    }\r\n  }\r\n};\r\n\r\nmodule.exports = Detail;\r\n","'use strict';\r\n\r\nvar Base = require('./Base');\r\n\r\n/*\r\n* Base render prototype\r\n*/\r\nvar Entity = function(entity) {\r\n  if (!entity) {\r\n    throw 'Entity undefined';\r\n  }\r\n  this.entityModel = entity;\r\n  this.entityModel.view = this;\r\n  this.selected = false;\r\n};\r\n\r\nEntity.prototype.destroy = function() {\r\n  this.entityModel.view = null;\r\n  this.entityModel.destroy();\r\n  this.entityModel = null;\r\n};\r\n\r\nEntity.prototype.createGraphics = function(container, graphics) {\r\n  if (!graphics) {\r\n    graphics = new PIXI.Graphics();\r\n  }\r\n  Entity.setInteractive(graphics);\r\n  graphics._entityView = this;\r\n  // add it the container so we see it on our screens.\r\n  container.addChild(graphics);\r\n  return graphics;\r\n};\r\n\r\nEntity.prototype.destroyGraphics = function(container, graphics) {\r\n  if (graphics) {\r\n    //graphics.clear();\r\n    graphics.destroy();\r\n    container.removeChild(graphics);\r\n  }\r\n};\r\n\r\nEntity.setInteractive = function(displayObject) {\r\n  displayObject.interactive = true;\r\n  displayObject.buttonMode = true;\r\n  displayObject.mouseover = Entity.mouseover;\r\n  displayObject.mouseout = Entity.mouseout;\r\n  displayObject.mousedown = Entity.mousedown;\r\n  displayObject.mouseup = Entity.mouseup;\r\n  displayObject.mousemove = Entity.mousemove;\r\n};\r\n\r\nEntity.prototype.render = function(graphics) {\r\n  //this.display.clear();\r\n};\r\n\r\nEntity.prototype.getPos = function() {\r\n  return this.entityModel.pos;\r\n};\r\n\r\nEntity.mousedown = null;\r\nEntity.mousemove = null;\r\nEntity.mouseup = null;\r\nEntity.mouseover = null;\r\nEntity.mouseout = null;\r\n\r\nmodule.exports = Entity;\r\n","'use strict';\n\nvar GroupModel = require('CrowdSim').Group;\nvar Base = require('./Base');\nvar Entity = require('./Entity');\nvar Detail = require('./Detail');\nvar Colors = Base.Colors;\n\nvar Group = function(group) {\n  if (!group) {\n    throw 'Group object must be defined';\n  }\n  Entity.call(this, group);\n};\n\nGroup.CreateFromModel = function(group) {\n  return new Group(group);\n};\n\nGroup.CreateFromPoint = function(x, y, parent, options) {\n  var group = new GroupModel(x, y, parent, options);\n  return new Group(group);\n};\n\nGroup.prototype.destroy = function() {\n  Entity.prototype.destroyGraphics.call(this,Group.container, this.graphics);\n  Entity.prototype.destroy.call(this);\n};\n\nGroup.prototype.createGraphics = function(group) {\n  this.graphics = Entity.prototype.createGraphics.call(this,Group.container);\n  this.label = new PIXI.Text(group.id, Base.Fonts.default);\n  this.label.resolution = Base.Fonts.resolution;\n  this.graphics.addChild(this.label);\n  this.circle = new PIXI.Circle(group.pos[0], group.pos[1], group.getRadius());\n  this.circle.entityModel = group;\n  this.graphics.entity = this;\n};\n\nGroup.prototype.render = function(options) {\n  if (!Group.detail.level) {\n    this.graphics.clear();\n    return;\n  }\n  Entity.prototype.render.call(this,this.graphics);\n  var group = this.entityModel;\n  // init render\n  if (!this.graphics && Group.detail.level) {\n    this.createGraphics(group);\n  } else {\n    this.graphics.clear();\n  }\n\n  if (Group.detail.level > 0) {\n    this.label.x = group.pos[0] - this.label.width / 3;\n    this.label.y = group.pos[1] - this.label.height / 2;\n    this.circle.x = group.pos[0];\n    this.circle.y = group.pos[1];\n    this.circle.radius = group.getRadius();\n    this.graphics.beginFill(this.hover ? Colors.Hover : Colors.Group, this.hover ? 0.9 : 0.3);\n    this.graphics.drawShape(this.circle);\n    this.graphics.endFill();\n  }\n  if (Group.detail.level > 1) {\n    // draw helper lines to entities\n    var entities = group.entities;\n    this.graphics.lineStyle(0.2, Colors.Group, 0.3);\n    if (entities.path) {\n      this.graphics.moveTo(group.pos[0],group.pos[1]);\n      var start = entities.path.getJointByIdx(group.getPathStartIdx());\n      this.graphics.lineTo(start.pos[0],start.pos[1]);\n    }\n    if (entities.startContext) {\n      this.graphics.moveTo(group.pos[0],group.pos[1]);\n      this.graphics.lineTo(entities.startContext.pos[0],entities.startContext.pos[1]);\n    }\n    if (entities.endContext) {\n      this.graphics.moveTo(group.pos[0],group.pos[1]);\n      this.graphics.lineTo(entities.endContext.pos[0],entities.endContext.pos[1]);\n    }\n  }\n};\n\nGroup.prototype.getAnchor = function(init) {\n  var group = this.entityModel;\n  return {x: group.pos[0], y: group.pos[1]};\n};\n\nGroup.prototype.dragTo = function(pos, anchor) {\n  var group = this.entityModel;\n  group.pos[0] = pos.x;\n  group.pos[1] = pos.y;\n};\n\nGroup.prototype.getPos = function() {\n  return Entity.prototype.getPos.call(this);\n};\n\nGroup.prototype.getGroup = function() {\n  return this.entityModel;\n};\n\nGroup.detail = new Detail(2,2);\n\nmodule.exports = Group;\n","'use strict';\n\nvar Vec2 = require('CrowdSim').Vec2;\nvar Base = require('./Base');\nvar Entity = require('./Entity');\nvar Detail = require('./Detail');\nvar Colors = Base.Colors;\n\nvar Joint = function(joint, texture) {\n  if (!joint) {\n    throw 'Joint object must be defined';\n  }\n  Entity.call(this, joint);\n  this.texture = texture;\n};\n\nJoint.prototype.destroy = function(graphics) {\n  this.graphics.removeChild(this.label);\n  this.label.destroy();\n  Entity.prototype.destroyGraphics.call(this, this.graphics , this.sprite);\n  Entity.prototype.destroy.call(this);\n};\n\nJoint.prototype.createGraphics = function(graphics) {\n  this.graphics = graphics;\n  var joint = this.entityModel;\n  this.label = new PIXI.Text(joint.id, Base.Fonts.default);\n  this.label.resolution = Base.Fonts.resolution;\n  graphics.addChild(this.label);\n  this.sprite = new PIXI.Sprite(this.texture);\n  Entity.prototype.createGraphics.call(this, graphics, this.sprite);\n  this.sprite.anchor.x = 0.5;\n  this.sprite.anchor.y = 0.5;\n  this.sprite.entity = this;\n  this.sprite.alpha = 0.5;\n  this.render();\n};\n\nJoint.prototype.render = function() {\n  this.sprite.x = this.entityModel.pos[0];\n  this.sprite.y = this.entityModel.pos[1];\n  this.sprite.width = 2 * this.entityModel.getRadius();\n  this.sprite.height = 2 * this.entityModel.getRadius();\n  this.sprite.tint = this.hover ? Colors.Hover : Colors.Joint;\n  this.label.x = this.sprite.x - this.label.width / 3;\n  this.label.y = this.sprite.y - this.label.height / 2;\n};\n\nJoint.prototype.getAnchor = function(init) {\n  return {x: this.entityModel.pos[0], y: this.entityModel.pos[1]};\n};\n\nJoint.prototype.dragTo = function(pos, anchor) {\n  var anchorV2 = Vec2.fromValues(anchor.x,anchor.y);\n  var radius = Vec2.length(anchorV2);\n  var posV2 = Vec2.fromValues(pos.x,pos.y);\n  Vec2.subtract(posV2,posV2,this.entityModel.pos);\n  var newRadius = Vec2.length(posV2);\n  // drag to new position\n  this.entityModel.pos[0] = pos.x;\n  this.entityModel.pos[1] = pos.y;\n  this.sprite.x = pos.x;\n  this.sprite.y = pos.y;\n};\n\nJoint.prototype.getJoint = function() {\n  return this.entityModel;\n};\n\nJoint.prototype.getPos = function() {\n  return Entity.prototype.getPos.call(this);\n};\n\nmodule.exports = Joint;\n","'use strict';\n\nvar Base = require('./Base');\nvar Joint = require('./Joint');\nvar Entity = require('./Entity');\nvar Detail = require('./Detail');\nvar Colors = Base.Colors;\n\nvar LinePrototype = function(color) {\n\n  var Line = function(line) {\n    if (!line) {\n      throw 'Line object must be defined';\n    }\n    Entity.call(this, line);\n  };\n\n  Line.prototype.destroy = function() {\n    this.graphics.removeChild(this.label);\n    this.label.destroy();\n    Entity.prototype.destroyGraphics.call(this, Line.container, this.graphics);\n    Entity.prototype.destroy.call(this);\n  };\n\n  Line.prototype.createGraphics = function(line) {\n    this.graphics = Entity.prototype.createGraphics.call(this, Line.container);\n    this.label = new PIXI.Text(line.id, Base.Fonts.default);\n    this.label.resolution = Base.Fonts.resolution;\n    this.graphics.addChild(this.label);\n    var jts = line.getJoints();\n    this.label.x = jts[0].pos[0] - this.label.width / 2;\n    this.label.y = jts[0].pos[1] - this.label.height / 2;\n    if (jts && jts.length > 0) {\n      for (var i in jts) {\n        this.addJointFromModel(jts[i]);\n      }\n    }\n  };\n\n  Line.prototype.addJointFromModel = function(joint) {\n    var renderJoint = new Joint(joint, Line.texture);\n    renderJoint.createGraphics(this.graphics);\n    return renderJoint;\n  };\n\n  Line.prototype.addJoint = function(x, y, options) {\n    var line = this.entityModel;\n    var jt = line.addJoint(x, y, options);\n    return this.addJointFromModel(jt);\n  };\n\n  Line.prototype.render = function(options) {\n    if (!Line.detail.level) {\n      this.graphics.clear();\n      return;\n    }\n    Entity.prototype.render.call(this, this.graphics);\n    var line = this.entityModel;\n    var jts = line.getJoints();\n    // init render\n    if (!this.graphics && Line.detail.level > 0) {\n      this.createGraphics(line);\n    } else {\n      this.graphics.clear();\n    }\n\n    if (Line.detail.level > 0) {\n      var points  = [];\n      this.label.x = jts[0].pos[0] - this.label.width / 3;\n      this.label.y = jts[0].pos[1] - this.label.height ;\n      this.graphics.lineStyle(line.getWidth(), this.hover ? Colors.Hover : color, 0.6);\n      for (var i = 0; i < jts.length; i++) {\n        points.push(jts[i].pos[0], jts[i].pos[1]);\n        jts[i].view.render();\n      }\n      this.graphics.drawPolygon(points);\n    }\n    if (Line.detail.level > 1) {\n    }\n  };\n  return Line;\n};\n\nmodule.exports = LinePrototype;\n","'use strict';\n\nvar PathModel = require('CrowdSim').Path;\nvar Base = require('./Base');\nvar Entity = require('./Entity');\nvar Detail = require('./Detail');\nvar LinePrototype = require('./LinePrototype');\nvar Colors = Base.Colors;\n\nvar Path = LinePrototype(Colors.Path);\n\nPath.CreateFromModel = function(path) {\n  return new Path(path);\n};\n\nPath.CreateFromPoint = function(x, y, parent, options) {\n  var path = new PathModel(x, y, parent, options);\n  return new Path(path);\n};\n\nPath.prototype.getPos = function() {\n  return Entity.prototype.getPos.call(this);\n};\n\nPath.texture = null; // paths joint texture\nPath.detail = new Detail(2);\n\nmodule.exports = Path;\n","'use strict';\n\nvar Base = require('./Base');\nvar Colors = Base.Colors;\n\nvar Render = function(canvas, w, h, options) {\n  this.options = Lazy(options).defaults(Render.defaults).toObject();\n  // create a renderer instance.\n  this._renderer = PIXI.autoDetectRenderer(w, h);\n  this._renderer.autoResize = true;\n  // add the renderer view element to the DOM\n  canvas.appendChild(this._renderer.view);\n\n  // create root container\n  this._stage = new PIXI.Container();\n  this._stage.scale.x = this.options.scale;\n  this._stage.scale.y = this.options.scale; // 10pix ~ 1m\n  // create agents container\n  this._worldContainer = new PIXI.Container();\n  this._agentsContainer = new PIXI.ParticleContainer(this.options.maxAgents, {\n    scale: true,\n    position: true,\n    rotation: true,\n    uvs: true,\n    alpha: true\n  });\n  this._stage.addChild(this._agentsContainer);\n  this._stage.addChild(this._worldContainer);\n\n  if (this.options.debug) {\n    this._debugContainer = new PIXI.Container();\n    this._stage.addChild(this._debugContainer);\n  }\n\n};\n\nRender.prototype.init = function(textures, events) {\n  var baseTextures = PIXI.Texture.fromImage(textures.file),\n      a = textures.agent,\n      w = textures.wall,\n      p = textures.path;\n  Render.Agent.texture = new PIXI.Texture(baseTextures, new PIXI.Rectangle(a[0], a[1], a[2], a[3]));\n  Render.Wall.texture = new PIXI.Texture(baseTextures, new PIXI.Rectangle(w[0], w[1], w[2], w[3]));\n  Render.Path.texture = new PIXI.Texture(baseTextures, new PIXI.Rectangle(p[0], p[1], p[2], p[3]));\n\n  this._worldContainer.removeChildren();\n  this._agentsContainer.removeChildren();\n  // init default containers\n\n  Render.Agent.container = this._agentsContainer;\n  Render.Agent.debugContainer = this._debugContainer;\n  Render.Context.container = this._worldContainer;\n  Render.Group.container = this._worldContainer;\n  Render.Wall.container = this._worldContainer;\n  Render.Path.container = this._worldContainer;\n\n  // to draw everything\n  //App._renderOnce();\n\n  // wire Entity events\n  Render.Entity.mouseover = events.mouseover;\n  Render.Entity.mouseout = events.mouseout;\n  Render.Entity.mousedown = events.mousedown;\n  Render.Entity.mouseup = events.mouseup;\n  Render.Entity.mousemove = events.mousemove;\n\n  // axis\n  var graphicsAux = new PIXI.Graphics();\n  graphicsAux.lineStyle(0.2, Colors.Helpers);\n  // x\n  var length = 5;\n  graphicsAux.moveTo(0, 0);\n  graphicsAux.lineTo(length, 0);\n  graphicsAux.moveTo(length - 1, -1);\n  graphicsAux.lineTo(length, 0);\n  graphicsAux.lineTo(length - 1, 1);\n  // y\n  graphicsAux.moveTo(0, 0);\n  graphicsAux.lineTo(0, length);\n  graphicsAux.moveTo(-1, length - 1);\n  graphicsAux.lineTo(0, length);\n  graphicsAux.lineTo(1, length - 1);\n\n  // for temporary graphics\n  this._graphicsHelper = new PIXI.Graphics();\n\n  this._worldContainer.addChild(this._graphicsHelper);\n  this._worldContainer.addChild(graphicsAux);\n};\n\nRender.prototype.drawHelperLine = function(x0, y0, x1, y1) {\n  this._graphicsHelper.clear();\n  if (x0) {\n    this._graphicsHelper.clear();\n    this._graphicsHelper.lineStyle(0.2, Colors.Helpers);\n    this._graphicsHelper.moveTo(x0, y0);\n    this._graphicsHelper.lineTo(x1, y1);\n  }\n};\n\nRender.prototype.zoom = function(scale, x, y) {\n  scale = scale > 0 ? 1.1 : 0.9;\n  var currentWorldPos = this.screenToWorld(x, y);\n  this._stage.scale.x = this._stage.scale.x * scale;\n  this._stage.scale.y = this._stage.scale.y * scale;\n  var newScreenPos = this.worldToScreen(currentWorldPos.x, currentWorldPos.y);\n  this._stage.x -= (newScreenPos.x - x) ;\n  this._stage.y -= (newScreenPos.y - y) ;\n};\n\nRender.prototype.pan = function(dx, dy) {\n  this._stage.x += dx;\n  this._stage.y += dy;\n};\n\nRender.prototype.getWidth = function() {\n  return this._stage.width;\n};\n\nRender.prototype.getHeight = function() {\n  return this._stage.height;\n};\n\nRender.prototype.render = function() {\n  this._renderer.render(this._stage);\n};\n\nRender.prototype.screenToWorld = function(x, y) {\n  return {x: (x - this._stage.x) / this._stage.scale.x,\n          y: (y - this._stage.y) / this._stage.scale.y};\n};\nRender.prototype.worldToScreen = function(x, y) {\n  return {x: x * this._stage.scale.x + this._stage.x,\n          y: y * this._stage.scale.y + this._stage.y};\n};\n\nRender.Agent = require('./Agent');\nRender.Entity = require('./Entity');\nRender.Group = require('./Group');\nRender.Context = require('./Context');\nRender.Path = require('./Path');\nRender.Wall = require('./Wall');\nRender.Joint = require('./Joint');\n\nRender.defaults = {\n  scale: 10,\n  mxAgents: 1000, // to init particle container\n  debug: false,\n};\n\nmodule.exports = Render;\n","'use strict';\n\nvar WallModel = require('CrowdSim').Wall;\nvar Base = require('./Base');\nvar Entity = require('./Entity');\nvar LinePrototype = require('./LinePrototype');\nvar Detail = require('./Detail');\nvar Colors = Base.Colors;\nvar Fonts = Base.Fonts;\n\nvar Wall = LinePrototype(Colors.Wall);\n\nWall.CreateFromModel = function(wall) {\n  return new Wall(wall);\n};\n\nWall.CreateFromPoint = function(x, y, parent, options) {\n  var wall = new WallModel(x, y, parent, options);\n  return new Wall(wall);\n};\n\nWall.prototype.getPos = function() {\n  return Entity.prototype.getPos.call(this);\n};\n\nWall.texture = null; // wall joints texture\nWall.detail = new Detail(2);\n\nmodule.exports = Wall;\n","'use strict';\nvar CrowdSim = require('CrowdSim');\n\nvar Worlds = {\n  world1: function(options) {\n    var world = new CrowdSim.World(0, 0, this, options);\n    // wire world events and adding entities functions\n    var sizeR = 20;\n    var sizeC = 10;\n    var door = sizeR / 8;\n    var cx = 55, cy = 45;\n    var gx = 65, gy = 50;\n    var radius = 4;\n    var waypoints = [[10, 10], [20, 21], [31, 30], [41, 41], [41, 75], [55, 80], [65, 70], [65, 60]];\n    var path = new CrowdSim.Path(null, null, world);\n    path.addJoints(waypoints);\n    path.reverse();\n\n    //var path = new CrowdSim.Path([{pos: [65, 60], radius: radius / 2}, {pos: [65, 70], radius: radius / 2}, {pos: [55, 80], radius: 2 * radius}]);\n\n    var startContext = new CrowdSim.Context(gx, gy, world, {width: sizeC, height: sizeC});\n    //var endContext = new CrowdSim.Context(55  , 80 - sizeC , sizeC, sizeC);\n    var endContext = new CrowdSim.Context(10, 10, world, {width: sizeC, height: sizeC});\n    var opts = {debug: options.debug,\n                agentsCount: 10,\n                agentsMax: 1000,\n                agentsSizeMin: 0.5,\n                agentsSizeMax: 0.6,\n                startProb: 0.1,\n                startRate: 1,\n                endProb: 0.1,\n                endRate: 1};\n    var group = new CrowdSim.Group(60, 30, world, opts);\n    group.assignStartContext(startContext);\n    group.assignEndContext(endContext);\n    group.assignPath(path);\n    var room1 = [[cx + sizeR / 2 - door, cy + sizeR], [cx, cy + sizeR], [cx, cy],\n              [cx + sizeR, cy], [cx + sizeR, cy + sizeR], [cx + sizeR / 2 + door, cy + sizeR]];\n    var room = [[cx + sizeR / 2 - door, cy + sizeR], [cx, cy + sizeR]];\n    //var wall = new CrowdSim.Wall(room);\n    var wall = new CrowdSim.Wall(null, null, world);\n    wall.addJoints(room1);\n    return world;\n  }\n};\n\nmodule.exports = Worlds;\n"]}